\lecture{3}{19 nov}{\dag}

\section{Теорема Кука-Левина}
$ \tThreeSAT = \{(F, A) \mid F \text{ --- в 3-КНФ}, F(A) = 1\}$.
\begin{thm}[Кук-Левин]
	$ 3-\SAT$ --- \NP-полная задача. 
\end{thm}
\begin{proof}
	Мы уже доказали полноту задач выполнимости булевых схем, поэтому будем сводить к ней.

	Пусть у нас есть некоторая схема. Для каждого гейта заведем по переменной, которая обозначает результат операции в этом гейте. Входы тоже остаются гейтами в схеме.

	Запишем для гейтов клозы длины 3, которые выражают результат в зависимости от аргументов.

	Например, для входов $ x, y$ и операции $ \plus = g(x, y)$, 
	\[
	\begin{aligned}
		&(x \vee y \vee \neg g) \\
		&(\neg x \vee \neg y \vee \neg g) \\
		&(x \vee \neg y\vee g) \\
		&(\neg x \vee y \vee g)
	\end{aligned}
	\]

	Еще для последнего гейта $ g$ (выходного) запишем клоз $ (g)$.

	Значение в полученной схеме будет соответствовать результату конъюнкции всех переменных и наоборот: по формуле можем построить булеву схему и входные переменные выполняют ее.
\end{proof}
\begin{thm}
	Пусть $ R \in \tNP$, и соответствующий язык полон  $ L(R) $ --- \NP-полон. Тогда  $ R$ сводится по Тьюрингу к $ L(R)$.
\end{thm}
\begin{proof}
	Во-первых, задача поиска из $ \NP$ сводится к $ \tSAT$. При этом $ \SAT$ сводится к $ L(R)$.
	
	Осталось свести $ \tSAT \to \SAT$. Пусть нам дали выполняющий набор для $ F$. Подставим первую переменную $ x_1$  как $0$ и как $ 1$ в $ F$ (это тоже формулы) и спросим у оракула $ \SAT$ про $ F[x_1=0] \in \SAT$  и $ F[x_1=1] \in \SAT$.

	Так как $ F$ выполнима, хотя бы одна из полученных схем выполнима. Выберем ее и продолжим подставлять в нее. Так мы дойдем до конечной истиной формулы. Следовательно, последовательность подставляемых значений $ x_i$ и будет выполняющим набором.
\end{proof}
\subsection{Оптимальный алгоритм для $\tNP$-задачи}
Пусть мы хотим решить задачу, заданную отношениям $ R$, с входом $ x$.
Давайте переберем все машины (не только полиномиальные) и, если какая-то машина выдала результат $ y $ проверим его $ R(x, y)$ за полином. Если ответ подошел, то просто заканчиваем работу, иначе продолжаем ждать других результатов.

Если машины были бы запущены параллельно, то мы бы нашли ответ за время самой быстрой машины на данном входе.

А мы будем делать шаги <<змейкой>>: выделим для $ l$-ой машины $ 2^{-l}$ времени. 

На очередном этапе $ 2^{l}(1 + 2k)$ будем моделировать $ k$-ый шаг машины $ M$. 

Посчитаем замедление алгоритма. Мы хотим выдать ответ не сильно позже, чем самая быстрая машина. Но заметим, что такая машина одна, поэтому $ l$ это константа, следовательно, множитель $ 2^{l}$ тоже константа.

Как моделировать эти машины? Если было бы быстрое обращение к каждому элементу памяти, то $ t(x) \le const_i \cdot t_i + p(\lvert x \rvert )$ (последнее на проверку), в случае с ДМТ получаем  $ t(x) \le const_{i}\cdot p(t_i(x))$.

% ~20 минут

